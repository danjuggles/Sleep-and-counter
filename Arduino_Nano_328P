#include <avr/sleep.h>
#include <avr/power.h>


//Pin Mapping
const int countInterruptPin = 2;   //Input signal from sensor to wake up counter if in sleep mode (looking for LOW as internal pullup resistor is used)
//const int shareInterruptPin = 3;  //Signal to send counter into 'share' mode
//const int ledPin = 6;    //Debugging tool providing visual indicator as to when a pulse is detected

//Global variables
int counterState = 0;       //current count button state
int counterStatePrv = 0;    //previous count button state
int sleepNumber;
int sleepYN = 1;

unsigned long lastDebounceTime = 0;       //Last time output was toggled - Count
unsigned long debounceDelay = 10;     //Debounce time on the input button
unsigned long g_sleepDelay = 5000;     //Time with no pulses before sleep

unsigned long countNumber;      //unsigned 32bit variable


/***************************************************/
void setup()
{
  noInterrupts();
  
  Serial.begin(9600);

  /* Setup the pin direction. */
for (byte i = 0; i <= A5; i++)
    {
    pinMode (i, OUTPUT);    // changed as per below
    digitalWrite (i, LOW);  //     ditto
    }

pinMode(countInterruptPin, INPUT_PULLUP);

  // disable ADC
  ADCSRA = 0;

  // turn off various modules (must come after disable ADC)
power_adc_disable(); // ADC converter
power_spi_disable(); // SPI
power_usart0_enable();// Serial (USART) 
power_timer0_enable();// Timer 0
power_timer1_disable();// Timer 1
power_timer2_disable();// Timer 2
power_twi_disable(); // TWI (I2C)  

 // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);  // turn on brown-out enable select
  MCUCR = bit (BODS);        // this must be done within 4 clock cycles of above
  
  Serial.println("Initialisation complete.");
  
  //delay(100);
  
  interrupts();
}

/***************************************************/
void loop()
{
   //digitalWrite(ledPin, HIGH);   //Turn onboard LED ON


   //////////COUNTER LOGIC//////////
   
  counterState = digitalRead(countInterruptPin);   //Read the status of the counter input

  if (counterState != counterStatePrv) // If the switch changed, due to noise or pressing
    {
   
      if ((millis() - lastDebounceTime) > debounceDelay) 
      {

        lastDebounceTime = millis();    //set debounce time to be the clock time

        if (counterState == LOW)          //check for pulse
        {

          //digitalWrite(ledPin, HIGH);   //Turn onboard LED ON

          countNumber++;      //increment (add 1) to the stored count value

          sleepYN = 1;
          
          Serial.println(countNumber);

          //Call a void loop responsible for memory allocation of o/p
          //splitCountValue();

          //Call a void loop responsible for printing the o/p
          //printCountValue();

        }
        
      }
      
      else 
      { 
        //digitalWrite(ledPin, LOW); 
      }
      
    }

    counterStatePrv = counterState;
    
  //////////SLEEP LOGIC//////////
 if (((millis() - lastDebounceTime) > g_sleepDelay) && (sleepYN==1))
    {
       if (counterState == counterStatePrv) // If the switch changed, due to noise or pressing
       {
        sleepYN = 0;
        sleepLoop();
       }
    }


}

/***************************************************/
void sleepLoop()
{
  sleepNumber++;
  Serial.print("S");
  //Serial.println(sleepNumber);

  delay(50);

  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_enable();
  noInterrupts();

  attachInterrupt(digitalPinToInterrupt(countInterruptPin), sleepInterrupt, LOW);
  //sleep_mode();
  interrupts();
  sleep_cpu();
  
  //The program will continue from here.
  
  //First thing to do is disable sleep.
  sleep_disable(); 
}

/***************************************************/
void sleepInterrupt(void)
{
  sleep_disable(); 
  detachInterrupt(0);
  detachInterrupt(digitalPinToInterrupt(countInterruptPin));
  //Serial.println("Interrupt triggered");
}
