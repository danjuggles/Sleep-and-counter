#include <avr/sleep.h>
#include <avr/power.h>


//Pin Mapping
const int countInputPin = 6;     //Input signal from sensor (looking for LOW as internal pullup resistor is used)
const int countInterruptPin = 2;   //Input signal from sensor to wake up counter if in sleep mode (looking for LOW as internal pullup resistor is used)
const int shareInterruptPin = 3;  //Signal to send counter into 'share' mode
const int ledPin = 13;    //Debugging tool providing visual indicator as to when a pulse is detected

//Global variables
int counterState = 0;       //current count button state
int counterStatePrv = 0;    //previous count button state
int sleepNumber;
int g_shareMode = 0;

unsigned long lastDebounceTime = 0;       //Last time output was toggled - Count
unsigned long debounceDelay = 10;     //Debounce time on the input button
unsigned long g_sleepDelay = 5000;     //Time with no pulses before sleep

unsigned long countNumber;      //unsigned 32bit variable


/***************************************************/
void setup()
{
  Serial.begin(9600);

  //Sets OUTPUT pins
  pinMode(ledPin, OUTPUT);
  
  /* Setup the pin direction. */
  pinMode(countInputPin, INPUT_PULLUP);
  pinMode(countInterruptPin, INPUT_PULLUP);
  pinMode(shareInterruptPin, INPUT_PULLUP);  
  
  Serial.println("Initialisation complete.");
  //attachInterrupt(digitalPinToInterrupt(interruptPin), sleepInterrupt, FALLING);
  attachInterrupt(digitalPinToInterrupt(shareInterruptPin), shareInterrupt, LOW);
  
  delay(100);
  
}

/***************************************************/
void loop()
{
   //digitalWrite(ledPin, HIGH);   //Turn onboard LED ON  
  
    attachInterrupt(digitalPinToInterrupt(shareInterruptPin), shareInterrupt, FALLING);

  //////////COUNTER LOGIC//////////
   counterState = digitalRead(countInputPin);   //Read the status of the counter input
    
  if (counterState != counterStatePrv) // If the switch changed, due to noise or pressing
    {

      if ((millis() - lastDebounceTime) > debounceDelay) 
      {

        lastDebounceTime = millis();    //set debounce time to be the clock time

        if (counterState == LOW)          //check for pulse
        {

          //digitalWrite(ledPin, HIGH);   //Turn onboard LED ON

          countNumber++;      //increment (add 1) to the stored count value

          //Serial.println(countNumber);

          //Call a void loop responsible for memory allocation of o/p
          //splitCountValue();

          //Call a void loop responsible for printing the o/p
          //printCountValue();

        }
        
      }
      
      else 
      { 
        digitalWrite(ledPin, LOW); 
      }
      
    }

    counterStatePrv = counterState;

  //////////SLEEP LOGIC//////////
 if ((millis() - lastDebounceTime) > g_sleepDelay) 
    {
      //Serial.println("getting tired!");
      //digitalWrite(ledPin, LOW);   //Turn onboard LED OFF
      sleepLoop();
    }

  //////////SHARE LOGIC//////////
  if (g_shareMode == 1)
  {
    delay(1000);
    Serial.println(countNumber);
    g_shareMode = 0;
  }

}


/***************************************************/
void shareInterrupt(void)
{
  sleep_disable(); 
  detachInterrupt(digitalPinToInterrupt(shareInterruptPin));
  //shareData();
  g_shareMode = 1;
}

void shareData()
{
  Serial.println("Share Interrupt triggered");
  Serial.println(countNumber);
  Serial.println();
}
/***************************************************/
void sleepLoop()
{
  attachInterrupt(digitalPinToInterrupt(countInterruptPin), sleepInterrupt, LOW);
  enterSleep();      
}


/***************************************************/
void enterSleep(void)
{
  
  //Setup pin2 as an interrupt and attach handler. 
  //attachInterrupt(digitalPinToInterrupt(pin2), pin2Interrupt, RISING);
  //Serial.println("Getting sleepy");
  //digitalWrite(ledPin, LOW);   //Turn onboard LED OFF
  sleepNumber++;
  Serial.print("Sleep number: ");
  Serial.println(sleepNumber);

  delay(100);

  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  
  sleep_enable();
  
  sleep_mode();
  
  //The program will continue from here.
  
  //First thing to do is disable sleep.
  sleep_disable(); 

}


/***************************************************/
void sleepInterrupt(void)
{
  /* This will bring us back from sleep. */
  
  /* We detach the interrupt to stop it from 
   * continuously firing while the interrupt pin
   * is low.*/
  sleep_disable(); 
  //detachInterrupt(0);
  detachInterrupt(digitalPinToInterrupt(countInterruptPin));
  Serial.println("Interrupt triggered");
  //digitalWrite(ledPin, LOW);   //Turn onboard LED OFF
  //noInterrupts();
}
